<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>dino banana</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family:
          "Inter",
          -apple-system,
          BlinkMacSystemFont,
          "Segoe UI",
          Roboto,
          Helvetica,
          Arial,
          sans-serif;
      }
      /* Custom styles for the range slider */
      input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 0.5rem;
        background: #fff7b8; /* gray-700 */
        border-radius: 0.25rem;
        outline: none;
        opacity: 0.7;
        transition: opacity 0.2s;
      }
      input[type="range"]:hover {
        opacity: 1;
      }
      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 1.25rem;
        height: 1.25rem;
        background: #ffc823; /* blue-300 */
        cursor: pointer;
        border-radius: 50%;
      }
      input[type="range"]::-moz-range-thumb {
        width: 1.25rem;
        height: 1.25rem;
        background: #ffc823; /* blue-300 */
        cursor: pointer;
        border-radius: 50%;
      }

      /* Styles for the "Overlay/Heatmap" toggle */
      #modeToggle:checked ~ .dot {
        transform: translateX(1.5rem); /* 24px */
      }
      #modeToggle:checked ~ .block {
        background-color: #ffc823; /* blue-500 */
      }
      #modeToggle:not(:checked) ~ .block {
        background-color: #4a5568; /* gray-600 */
      }

      /* NEW: Styles for the "Select/Unselect" toggle */
      #selectionModeToggle:checked ~ .dot {
        transform: translateX(1.5rem);
      }
      #selectionModeToggle:checked ~ .block {
        background-color: #ca8a04; /* blue-500 for Select */
      }
      #selectionModeToggle:not(:checked) ~ .block {
        background-color: #ef4444; /* red-500 for Unselect */
      }
      /* Ensure canvases are responsive within their containers */
      #previewCanvas,
      #imageCanvas,
      #outCanvas {
          max-width: 100%;
          max-height: 100%;
          object-fit: contain;
      }
    </style>
  </head>
  <body class="bg-stone-900 text-cyan-50 flex flex-col items-center min-h-screen p-4 sm:p-6 lg:p-8">
    <div
      class="w-full max-w-5xl bg-gray-800/50 backdrop-blur-sm shadow-2xl shadow-black/30 border border-gray-700 p-6 text-center"
    >
      <div class="flex flex-col md:flex-row gap-4 items-center justify-center w-full">
          <div id="dropZone" class="relative flex-grow flex flex-col items-center justify-center bg-gray-900/50 border-2 border-dashed border-gray-600 px-4 py-1 text-center group hover:border-blue-500 transition-colors duration-300 min-h-[100px]">
              <svg
                  class="w-10 h-10 mb-2 text-gray-500 group-hover:text-blue-500 transition-colors duration-300"
                  aria-hidden="true"
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                  viewBox="0 0 20 16"
              >
                  <path
                      stroke="currentColor"
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      stroke-width="1.5"
                      d="M13 13h3a3 3 0 0 0 0-6h-.025A5.56 5.56 0 0 0 16 6.5 5.5 5.5 0 0 0 5.207 5.021C5.137 5.017 5.071 5 5 5a4 4 0 0 0 0 8h2.167M10 15V6m0 0L8 8m2-2 2 2"
                  />
              </svg>
              <p class="font-semibold text-gray-300">Click to upload or drag & drop</p>
              <p class="text-xs text-gray-500 mb-2">PNG, JPG, or other image formats</p>
              <p class="text-sm text-gray-400">
                  Or
                  <button
                      id="exampleBtn"
                      class="relative z-10 text-blue-400 hover:text-blue-300 font-semibold underline bg-transparent border-none cursor-pointer p-0"
                  >
                      try an example</button
                  >.
              </p>
              <label for="imageLoader" class="absolute inset-0 cursor-pointer z-0"></label>
              <input type="file" id="imageLoader" accept="image/*" class="hidden" />
          </div>
          <div class="bg-gray-900/50 p-4 border border-gray-700 flex-grow">
              <label class="block text-xs text-gray-400 mb-1 text-left">Gemini API key</label>
              <input id="geminiKey" type="password" placeholder="nano-banana-key"
                  class="w-full px-3 py-2 bg-gray-800 border border-gray-600 text-sm">
          </div>
      </div>
    </div>
    
    <div class="w-full max-w-5xl bg-gray-800/50 backdrop-blur-sm shadow-2xl shadow-black/30 border border-gray-700 p-6 sm:p-8 text-center space-y-4 mb-6">
        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 items-center">
            <div class="flex items-center justify-center w-full space-x-3">
                <label for="scaleSlider" class="text-sm font-medium text-gray-400 whitespace-nowrap">Scale:</label>
                <input id="scaleSlider" type="range" min="0.25" max="4" step="0.25" value="1" class="w-full" />
                <span id="scaleValue" class="text-sm font-medium text-gray-400 w-12 text-right">1.00x</span>
            </div>

                    <div class="flex items-center justify-center space-x-3">
            <span class="text-sm font-medium text-gray-400">Unselect</span>
            <label for="selectionModeToggle" class="flex items-center cursor-pointer">
                <div class="relative">
                    <input type="checkbox" id="selectionModeToggle" class="sr-only" checked />
                    <div class="block bg-gray-600 w-14 h-8 rounded-full transition-colors"></div>
                    <div class="dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition transform"></div>
                </div>
            </label>
            <span class="text-sm font-medium text-gray-400">Select</span>
        </div>
        </div>
        <label class="text-xs text-gray-400 flex items-center gap-2" style="font-size: medium;">
            <input type="checkbox" id="livePreviewToggle" checked />
            Live preview threshold
        </label>
        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 items-center" id="exportControls">
            <div class="flex items-center justify-center w-full space-x-3">
                <label for="thresholdSlider" class="text-sm font-medium text-gray-400 whitespace-nowrap">Threshold:</label>
                <input id="thresholdSlider" type="range" min="0" max="1" step="0.01" value="0.5" class="w-full" />
                <span id="thresholdValue" class="text-sm font-medium text-gray-400 w-12 text-right">0.50</span>
            </div>

                    <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-4 items-center justify-center">
            <button
                id="clearBtn"
                class="hidden px-4 py-2 text-sm font-medium bg-gray-600 hover:bg-gray-700 text-gray-200 transition-colors"
            >
                Clear Selection
            </button>
            <button
                id="exportBtn"
                class="hidden px-4 py-2 text-sm font-medium bg-blue-500 hover:bg-blue-600 text-white transition-colors"
            >
                Export Selection
            </button>
        </div>

        </div>
    </div>

        <div id="status" class="flex items-center justify-center w-full max-w-5xl font-medium text-gray-400 h-6" style="font-size: x-large; padding-bottom: 1.5rem;">
        <svg
            id="spinner"
            class="animate-spin mr-3 h-5 w-5 text-blue-400 hidden"
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
        >
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path
                class="opacity-75"
                fill="currentColor"
                d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
            ></path>
        </svg>
        <span id="statusText"></span>
    </div>

    <div class="w-full max-w-5xl flex flex-col gap-4 my-auto mb-6">
        <div class="grid grid-cols-1 sm:grid-cols-4 gap-4 items-center justify-items-center">
            <div id="previewCanvasContainer" class="flex items-center justify-center p-2 border border-gray-700 shadow-inner overflow-hidden min-h-[200px] bg-gray-900/50 w-full h-full col-span-1">
                <canvas id="previewCanvas" class="hidden block max-w-full h-auto"></canvas>
                <div id="previewPlaceholder" class="text-gray-500 text-center text-sm"></div>
            </div>
            <div id="imageCanvasContainer" class="flex items-center justify-center p-2 border border-gray-700 shadow-inner overflow-hidden min-h-[250px] bg-gray-900/50 w-full h-full col-span-3">
                <canvas id="imageCanvas" class="hidden cursor-crosshair block max-w-full h-auto"></canvas>
                <div id="canvasPlaceholder" class="text-gray-500 text-center">Your image will appear here</div>
            </div>
        </div>
        
        <div class="bg-gray-900/50 p-4 border border-gray-700">
            <label class="block text-xs text-gray-400 mb-1 text-left">Prompt for patch</label>
            <textarea id="geminiPrompt" rows="2" class="w-full px-3 py-2 bg-gray-800 border border-gray-600 text-sm"
                placeholder="e.g. turn the cat into a tiger"></textarea>
            <button id="geminiSend"
                class="mt-3 w-full px-4 py-2 text-sm font-medium bg-yellow-500 hover:bg-yellow-700 text-white transition-colors">
                Send patch to Gemini
            </button>
        </div>

        <div id="outCanvasContainer" class="flex items-center justify-center p-2 border border-gray-700 shadow-inner overflow-hidden min-h-[300px] bg-gray-900/50 w-full h-full">
            <canvas id="outCanvas" class="hidden block max-w-full h-auto"></canvas>
            <div id="outPlaceholder" class="text-gray-500 text-center text-sm"></div>
        </div>
    </div>
    

    <script id="workerScript" type="module">
      import { pipeline, RawImage, matmul } from "https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.7.2";

      let extractor = null;
      let patchSize = null;

      self.onmessage = async (e) => {
        const { type, payload } = e.data;

        if (type === "init") {
          try {
            const { device, dtype } = payload;
            extractor = await pipeline("image-feature-extraction", "onnx-community/dinov3-vits16-pretrain-lvd1689m-ONNX", {
              device,
              dtype,
            });
            extractor.processor.image_processor.do_resize = false;
            patchSize = extractor.model.config.patch_size;
            self.postMessage({ type: "ready", payload: { patchSize } });
          } catch (error) {
            console.error("Worker init error:", error);
            self.postMessage({ type: "error", payload: "Failed to initialize model." });
          }
        } else if (type === "processImage") {
          const { imageData, width, height } = payload;
          try {
            const rawImage = new RawImage(imageData, width, height, 4);
            const features = await extractor(rawImage, { pooling: "none" });
            const numRegisterTokens = extractor.model.config.num_register_tokens ?? 0;
            const startIndex = 1 + numRegisterTokens;
            const patchFeatures = features.slice(null, [startIndex, null]);
            const normalizedFeatures = patchFeatures.normalize(2, -1);
            const scores = await matmul(normalizedFeatures, normalizedFeatures.permute(0, 2, 1));
            const similarityScores = (await scores.tolist())[0];
            self.postMessage({ type: "done", payload: { similarityScores } });
          } catch (error) {
            console.error("Worker processing error:", error);
            self.postMessage({ type: "error", payload: "An error occurred during image processing." });
          }
        }
      };
    </script>

    <script type="module">
      let patchesPerRow = 0;   // set once after DINO returns
      let dinoPatchSize = 0;   // set once after model ready
      let exportCanvas = null;   // transparent crop canvas
      let patchCenter  = null;   // centre in original-image pixels
      import { GoogleGenAI } from "https://esm.run/@google/genai";

      /* ----------  NEW: smooth patch + outlier removal  ---------- */
function removeOutliers(indices, ppr) {
  const s = new Set(indices);
  const out = [];
  for (const i of indices) {
    const x = i % ppr, y = Math.floor(i / ppr);
    let neighbours = 0;
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        if (s.has((y + dy) * ppr + (x + dx))) neighbours++;
      }
    }
    if (neighbours >= 2) out.push(i);   // keep only if ≥2 neighbours
  }
  return out;
}

function buildSmoothPatchCanvas(srcCanvas, keptIndices, radius, patchSize, ppr) {
  const R = Math.max(1, Math.round(radius));          // integer feather radius
  const kept = removeOutliers(keptIndices, ppr);      // 1. drop outliers
  if (kept.length === 0) return null;

  // ----- bounding box in patch coords -----
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const i of kept) {
    const px = i % ppr, py = Math.floor(i / ppr);
    minX = Math.min(minX, px); maxX = Math.max(maxX, px);
    minY = Math.min(minY, py); maxY = Math.max(maxY, py);
  }
  const pw = (maxX - minX + 1) * patchSize;
  const ph = (maxY - minY + 1) * patchSize;

  // ----- destination canvas (larger because of border) -----
  const dst = document.createElement('canvas');
  dst.width  = pw + 2 * R;
  dst.height = ph + 2 * R;
  const dstCtx = dst.getContext('2d');

  // ----- temporary mask (1-bit) -----
  const mask = document.createElement('canvas');
const MARGIN = 24; // px – keep away from rectangle edges
mask.width  = pw + MARGIN * 2;
mask.height = ph + MARGIN * 2;

mCtx.fillStyle = '#fff';
for (const i of kept) {
  const px = i % ppr, py = Math.floor(i / ppr);
  mCtx.fillRect((px - minX) * pSize + MARGIN,
                (py - minY) * pSize + MARGIN,
                pSize, pSize);
}

  // ----- feather the mask -----
  dstCtx.filter = `blur(${R}px)`;
  dstCtx.drawImage(mask, R, R);
  dstCtx.filter = 'none';

  // ----- compose: (feathered mask) * (raw patch) -----
  dstCtx.globalCompositeOperation = 'source-in';
  dstCtx.drawImage(srcCanvas,
                   minX * patchSize, minY * patchSize, pw, ph,
                   R, R, pw, ph);

  dstCtx.globalCompositeOperation = 'source-over';
  return { canvas: dst, minPatchX: minX, minPatchY: minY, maxPatchX: maxX, maxPatchY: maxY };
}

/* ----------  replace the old rebuildCropForGemini  ---------- */
function rebuildCropForGemini() {
  if (positivePatches.size === 0) {
    exportCanvas = null; patchCenter = null;
    document.getElementById('geminiSend').disabled = true;
    return;
  }
  const threshold = parseFloat(thresholdSlider.value);
  const combined = cachedCombinedScores;
  const kept = [];
  for (let i = 0; i < combined.length; i++)
    if (combined[i] >= threshold) kept.push(i);

  const src = document.createElement('canvas');
  src.width  = imageCanvas.width;
  src.height = imageCanvas.height;
  src.getContext('2d').drawImage(originalImage, 0, 0);

  const smooth = buildSmoothPatchCanvas(src, kept, 6, patchSize, patchesPerRow); // 6 px feather
  if (!smooth) { exportCanvas = null; patchCenter = null; document.getElementById('geminiSend').disabled = true; return; }

  exportCanvas = smooth.canvas;

  // centre in ORIGINAL (un-scaled) pixels
  const scaleW = originalImage.naturalWidth  / imageCanvas.width;
  const scaleH = originalImage.naturalHeight / imageCanvas.height;
  patchCenter = {
    x: (smooth.minPatchX + (smooth.maxPatchX - smooth.minPatchX + 1) / 2) * patchSize * scaleW,
    y: (smooth.minPatchY + (smooth.maxPatchY - smooth.minPatchY + 1) / 2) * patchSize * scaleH
  };
  document.getElementById('geminiSend').disabled = false;
}

      document.addEventListener('DOMContentLoaded', () => {
        // --- 1. Configuration & Global Variables ---
        const MODEL_ID = "onnx-community/dinov3-vits16-pretrain-lvd1689m-ONNX";
        const EXAMPLE_IMAGE_URL =
          "https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/cats.png";

        // DOM Elements
        const imageLoader = document.getElementById("imageLoader");
        const exampleBtn = document.getElementById("exampleBtn");
        const imageCanvas = document.getElementById("imageCanvas");
        const ctx = imageCanvas.getContext("2d");
        const spinner = document.getElementById("spinner");
        const statusText = document.getElementById("statusText");
        const canvasContainer = document.getElementById("canvasContainer");
        const canvasPlaceholder = document.getElementById("canvasPlaceholder");
        const dropZone = document.getElementById("dropZone");
        const modeToggle = document.getElementById("modeToggle");
        const scaleSlider = document.getElementById("scaleSlider");
        const scaleValue = document.getElementById("scaleValue");
        const clearBtn = document.getElementById("clearBtn");
        const exportBtn = document.getElementById("exportBtn");
        const thresholdSlider = document.getElementById("thresholdSlider");
        const thresholdValue = document.getElementById("thresholdValue");
        const exportControls = document.getElementById("exportControls");
        const selectionModeToggle = document.getElementById("selectionModeToggle");

        // Application State
        let worker = null;
        let similarityScores = null;
        let originalImage = null;
        let currentImageUrl = null;
        let patchSize = null;
        let isOverlayMode = true;
        let imageScale = 1.0;
        let maxPixels = null;
        let positivePatches = new Set();
        let negativePatches = new Set();
        let cachedCombinedScores = null;
        let lastHoverData = null;
        let animationFrameId = null;
        let isCanvasReady = false;
        let isSelectMode = true;

        // --- 2. Core Application Logic ---
        function updateStatus(text, isLoading = false) {
          statusText.textContent = text;
          spinner.style.display = isLoading ? "block" : "none";
        }

        async function initialize() {
          const isWebGpuSupported = !!navigator.gpu;
          const isMobile = /Mobi|Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent,
          );
          maxPixels = isMobile ? 1048576 : 2097152;

          const device = isWebGpuSupported ? "webgpu" : "wasm";
          const dtype = isWebGpuSupported ? "q4" : "q8";

          const blob = new Blob([document.getElementById("workerScript").textContent], {
            type: "application/javascript",
          });
          worker = new Worker(URL.createObjectURL(blob), { type: "module" });

          worker.onmessage = (e) => {
            const { type, payload } = e.data;
            if (type === "ready") {
              patchSize = payload.patchSize;
              dinoPatchSize = patchSize;      // <-- keep a copy
              updateStatus("Ready. Please select an image.");
            } else if (type === "done") {
              similarityScores = payload.similarityScores;
              patchesPerRow = imageCanvas.width / patchSize;   // <-- add this line
              isCanvasReady = true;
              updateStatus(
                `Image processed (${imageCanvas.width}x${imageCanvas.height}). Move over the image and click to select features.`,
              );
            } else if (type === "error") {
              updateStatus(payload);
            }
          };

          let statusMessage = `Loading model: ${device.toUpperCase()}`;
          if (isMobile) statusMessage += ". Mobile Detected.";
          updateStatus(statusMessage, true);

          worker.postMessage({ type: "init", payload: { device, dtype } });

          imageLoader.addEventListener("change", handleImageUpload);
          exampleBtn.addEventListener("click", handleExample);
          imageCanvas.addEventListener("mousemove", handleMouseMove);
          imageCanvas.addEventListener("mouseleave", handleMouseLeave);
          imageCanvas.addEventListener("click", handleCanvasClick);
          dropZone.addEventListener("dragover", handleDragOver);
          dropZone.addEventListener("dragleave", handleDragLeave);
          dropZone.addEventListener("drop", handleDrop);

          scaleSlider.addEventListener("input", handleSliderInput);
          scaleSlider.addEventListener("change", handleSliderChange);
thresholdSlider.addEventListener('input', e => {
  thresholdValue.textContent = parseFloat(e.target.value).toFixed(2);

  if (cachedCombinedScores) {          // we already have scores
    rebuildCropForGemini();            // rebuild feather & exportCanvas
    updatePreviewCanvas();             // show it instantly
    renderCanvas();                    // refresh main view
  }
});
          clearBtn.addEventListener("click", handleClearSelection);
          exportBtn.addEventListener("click", handleExportSelection);
          selectionModeToggle.addEventListener("change", (e) => {
            isSelectMode = e.target.checked;
          });
        }

        function handleImageUpload(event) {
          const file = event.target.files[0];
          if (file) loadImageOntoCanvas(URL.createObjectURL(file));
        }

        function handleExample() {
          updateStatus("Loading example image...", true);
          fetch(EXAMPLE_IMAGE_URL)
            .then(response => response.blob())
            .then(blob => loadImageOntoCanvas(URL.createObjectURL(blob)))
            .catch(error => {
              updateStatus("Failed to load example image.");
              console.error("Example load error:", error);
            });
        }

        function handleDragOver(event) {
          event.preventDefault();
          dropZone.classList.add("border-blue-500", "bg-gray-800");
        }

        function handleDragLeave(event) {
          event.preventDefault();
          dropZone.classList.remove("border-blue-500", "bg-gray-800");
        }

        function handleDrop(event) {
          event.preventDefault();
          dropZone.classList.remove("border-blue-500", "bg-gray-800");
          const file = event.dataTransfer.files[0];
          if (file && file.type.startsWith("image/")) {
            if (event.target.id === "exampleBtn") return;
            loadImageOntoCanvas(URL.createObjectURL(file));
          } else {
            updateStatus("Please drop an image file.");
          }
        }

        function handleMouseMove(event) {
          if (!isCanvasReady) return;

          const rect = imageCanvas.getBoundingClientRect();
          const scaleX = imageCanvas.width / rect.width;
          const scaleY = imageCanvas.height / rect.height;
          const canvasX = (event.clientX - rect.left) * scaleX;
          const canvasY = (event.clientY - rect.top) * scaleY;
          const patchesPerRow = imageCanvas.width / patchSize;
          const patchX = Math.floor(canvasX / patchSize);
          const patchY = Math.floor(canvasY / patchSize);
          const queryPatchIndex = patchY * patchesPerRow + patchX;

          if (queryPatchIndex >= 0 && queryPatchIndex < similarityScores.length) {
            lastHoverData = { queryIndex: queryPatchIndex };
          } else {
            lastHoverData = null;
          }

          if (!animationFrameId) {
            animationFrameId = requestAnimationFrame(() => {
              renderCanvas();
              animationFrameId = null;
            });
          }
        }

        function handleMouseLeave() {
          if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
          }
          lastHoverData = null;
          renderCanvas();
        }

        function handleSliderInput(event) {
          imageScale = parseFloat(event.target.value);
          scaleValue.textContent = `${imageScale.toFixed(2)}x`;
        }

        function handleSliderChange() {
          if (currentImageUrl) {
            loadImageOntoCanvas(currentImageUrl);
          }
        }
        /*added new function*/
        /* ----------  replace old rebuildCropForGemini  ---------- */
/* ----------------------------------------------------------
   REAL-TIME, ARTEFACT-FREE FEATHERED PATCH
----------------------------------------------------------*/
function rebuildCropForGemini() {
  /* 1.  early exits -------------------------------------------------------*/
  if (positivePatches.size === 0) {
    exportCanvas = null;
    patchCenter  = null;
    document.getElementById('geminiSend').disabled = true;
    return;
  }

  const threshold = parseFloat(thresholdSlider.value);
  const combined  = cachedCombinedScores;
  const ppr       = patchesPerRow;
  const pSize     = patchSize;

  /* 2.  current kept indices ---------------------------------------------*/
  const kept = [];
  for (let i = 0; i < combined.length; i++)
    if (combined[i] >= threshold) kept.push(i);

  if (kept.length === 0) {
    exportCanvas = null;
    patchCenter  = null;
    document.getElementById('geminiSend').disabled = true;
    return;
  }

  /* 3.  bounding box in PATCH coordinates --------------------------------*/
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const i of kept) {
    const px = i % ppr, py = Math.floor(i / ppr);
    minX = Math.min(minX, px); maxX = Math.max(maxX, px);
    minY = Math.min(minY, py); maxY = Math.max(maxY, py);
  }
  const pw = (maxX - minX + 1) * pSize;
  const ph = (maxY - minY + 1) * pSize;

const RAW_MARGIN = 24;          // extra transparent border
const FEATHER    = 12;          // px blur radius

/* ----  0.  source image (re-use the one you made)  ---- */
const src = document.createElement('canvas');
src.width  = imageCanvas.width;
src.height = imageCanvas.height;
src.getContext('2d').drawImage(originalImage, 0, 0);

/* 1.  build 1-bit mask – same size as before */
const mask = document.createElement('canvas');
mask.width  = pw + RAW_MARGIN * 2;
mask.height = ph + RAW_MARGIN * 2;
const mCtx = mask.getContext('2d');
mCtx.fillStyle = '#fff';
for (const i of kept) {
  const px = i % ppr, py = Math.floor(i / ppr);
  mCtx.fillRect((px - minX) * pSize + RAW_MARGIN,
                (py - minY) * pSize + RAW_MARGIN,
                pSize, pSize);
}

/* 2.  blur into a BIGGER canvas so no clipping */
const blurStage = document.createElement('canvas');
blurStage.width  = mask.width  + FEATHER * 4;
blurStage.height = mask.height + FEATHER * 4;
const bCtx = blurStage.getContext('2d');
bCtx.filter = `blur(${FEATHER}px)`;
bCtx.drawImage(mask, FEATHER * 2, FEATHER * 2);
bCtx.filter = 'none';

/* 3.  find tight bounding-box of the ALPHA channel */
const id  = bCtx.getImageData(0, 0, blurStage.width, blurStage.height);
const d   = id.data;
let minXb = blurStage.width, minYb = blurStage.height,
    maxXb = 0,               maxYb = 0;
for (let y = 0; y < blurStage.height; y++) {
  for (let x = 0; x < blurStage.width; x++) {
    const a = d[(y * blurStage.width + x) * 4 + 3]; // alpha byte
    if (a > 0) {
      minXb = Math.min(minXb, x);
      maxXb = Math.max(maxXb, x);
      minYb = Math.min(minYb, y);
      maxYb = Math.max(maxYb, y);
    }
  }
}
const cropW = maxXb - minXb + 1;
const cropH = maxYb - minYb + 1;

/* 4.  create the FINAL export canvas – exact tight size */
exportCanvas = document.createElement('canvas');
exportCanvas.width  = cropW;
exportCanvas.height = cropH;
const eCtx = exportCanvas.getContext('2d');
eCtx.drawImage(blurStage,
               minXb, minYb, cropW, cropH,
               0, 0, cropW, cropH);

/* 4b.  create the FINAL export canvas – exact tight size */
/* 5.  copy ALPHA first, then RGB inside it */
const rgbStage = document.createElement('canvas');
rgbStage.width  = cropW;
rgbStage.height = cropH;
const rCtx = rgbStage.getContext('2d');

rCtx.drawImage(exportCanvas, 0, 0);      // 1. alpha (feathered shape)
rCtx.globalCompositeOperation = 'source-in';
rCtx.drawImage(src,
               minX * pSize - RAW_MARGIN, minY * pSize - RAW_MARGIN,
               mask.width, mask.height,
               0, 0, mask.width, mask.height);
rCtx.globalCompositeOperation = 'source-over';

exportCanvas = rgbStage;                 // 2. final result: real pixels + feather
eCtx.globalCompositeOperation = 'source-in';   // keep only where alpha > 0
eCtx.drawImage(src,
               minX * pSize - RAW_MARGIN, minY * pSize - RAW_MARGIN,
               mask.width, mask.height,
               0, 0, mask.width, mask.height);
eCtx.globalCompositeOperation = 'source-over';

/* 6.  remember centre in ORIGINAL (un-scaled) pixels */
const scaleW = originalImage.naturalWidth  / imageCanvas.width;
const scaleH = originalImage.naturalHeight / imageCanvas.height;
patchCenter = {
  x: (minX + (maxX - minX + 1) / 2) * pSize * scaleW,
  y: (minY + (maxY - minY + 1) / 2) * pSize * scaleH
};

/* 7.  return / use rgbStage instead of exportCanvas from now on */
exportCanvas = rgbStage;   // feathered + tight + transparent

  document.getElementById('geminiSend').disabled = false;

  /* 8.  push the SAME canvas to live preview ---------------------------*/
  updatePreviewCanvas();   // re-use the already-built exportCanvas
}
/* ----------  /replacement  ---------- */

        function recalculateCombinedScores() {
          if (positivePatches.size === 0 && negativePatches.size === 0) {
            cachedCombinedScores = null;
            return;
          }

          const numPatches = similarityScores[0].length;
          const positiveScores = new Array(numPatches).fill(0);
          const negativeScores = new Array(numPatches).fill(0);

          // Calculate positive activations
          for (const queryIndex of positivePatches) {
            const scores = similarityScores[queryIndex];
            for (let i = 0; i < scores.length; i++) {
              positiveScores[i] = Math.max(positiveScores[i], scores[i]);
            }
          }

          // Calculate negative activations
          for (const queryIndex of negativePatches) {
            const scores = similarityScores[queryIndex];
            for (let i = 0; i < scores.length; i++) {
              negativeScores[i] = Math.max(negativeScores[i], scores[i]);
            }
          }

          // Subtract softened negative scores from positive scores
          cachedCombinedScores = new Array(numPatches);
          for (let i = 0; i < numPatches; i++) {
            const score = positivePatches.size > 0 ? positiveScores[i] - (negativeScores[i] * 0.4) : -1;
            cachedCombinedScores[i] = Math.max(-1, score);
          }
        }

        function updatePreviewCanvas() {
  const pv = document.getElementById('previewCanvas');
  const ph = document.getElementById('previewPlaceholder');

  if (!exportCanvas) {                       // nothing selected
    pv.classList.add('hidden');
    ph.classList.remove('hidden');
    return;
  }

  // 1. size the preview canvas to the **feathered** size
  pv.width  = exportCanvas.width;
  pv.height = exportCanvas.height;

  // 2. copy the **already feathered** exportCanvas 1:1
  const pvCtx = pv.getContext('2d');
  pvCtx.clearRect(0, 0, pv.width, pv.height);
  pvCtx.drawImage(exportCanvas, 0, 0);

  // 3. show / hide elements
  pv.classList.remove('hidden');
  ph.classList.add('hidden');
}

        function handleCanvasClick(event) {
          if (!isCanvasReady) return;

          const rect = imageCanvas.getBoundingClientRect();
          const scaleX = imageCanvas.width / rect.width;
          const scaleY = imageCanvas.height / rect.height;
          const canvasX = (event.clientX - rect.left) * scaleX;
          const canvasY = (event.clientY - rect.top) * scaleY;
          const patchesPerRow = imageCanvas.width / patchSize;
          const patchX = Math.floor(canvasX / patchSize);
          const patchY = Math.floor(canvasY / patchSize);
          const queryPatchIndex = patchY * patchesPerRow + patchX;

          if (queryPatchIndex >= 0 && queryPatchIndex < similarityScores.length) {
            const targetSet = isSelectMode ? positivePatches : negativePatches;
            const otherSet = isSelectMode ? negativePatches : positivePatches;

            if (targetSet.has(queryPatchIndex)) {
              targetSet.delete(queryPatchIndex);
            } else {
              targetSet.add(queryPatchIndex);
              otherSet.delete(queryPatchIndex);
            }

            recalculateCombinedScores();
            rebuildCropForGemini(); 
            renderCanvas();
            updatePreviewCanvas();
          }
        }

        function handleClearSelection() {
          positivePatches.clear();
          negativePatches.clear();
          recalculateCombinedScores();
          renderCanvas();
        }

        function handleExportSelection() {
          if (positivePatches.size === 0) {
            alert("Please make at least one positive selection to export.");
            return;
          }

          const threshold = parseFloat(thresholdSlider.value);
          const patchesPerRow = imageCanvas.width / patchSize;
          const combinedScores = cachedCombinedScores;

          const thresholdedPatches = [];
          for (let i = 0; i < combinedScores.length; i++) {
            if (combinedScores[i] >= threshold) {
              thresholdedPatches.push(i);
            }
          }

          if (thresholdedPatches.length === 0) {
            alert("No pixels found above the selected threshold. Try lowering the threshold or changing your selections.");
            return;
          }

          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          const link = document.createElement('a');
link.download = `dinov3_selection_t${threshold.toFixed(2)}.png`;
link.href = exportCanvas.toDataURL('image/png'); // already feathered
link.click();

          const croppedWidth = (maxX - minX + 1) * patchSize;
          const croppedHeight = (maxY - minY + 1) * patchSize;
          const exportCanvas = document.createElement("canvas");
          exportCanvas.width = croppedWidth;
          exportCanvas.height = croppedHeight;
          const exportCtx = exportCanvas.getContext("2d");

            // Create a temporary canvas to get the raw, unmasked pixel data from the scaled image.
            const tempCanvas = document.createElement("canvas");
            tempCanvas.width = imageCanvas.width;
            tempCanvas.height = imageCanvas.height;
            const tempCtx = tempCanvas.getContext("2d");
            tempCtx.drawImage(originalImage, 0, 0, imageCanvas.width, imageCanvas.height);

          for (const index of thresholdedPatches) {
            const patchY = Math.floor(index / patchesPerRow);
            const patchX = index % patchesPerRow;
            const sourceX = patchX * patchSize;
            const sourceY = patchY * patchSize;
            const targetX = (patchX - minX) * patchSize;
            const targetY = (patchY - minY) * patchSize;

            exportCtx.drawImage(
              tempCanvas, // Read from the unmasked, temporary canvas
              sourceX, sourceY, patchSize, patchSize,
              targetX, targetY, patchSize, patchSize
            );
          }

          /* -----  inside handleExportSelection, after creating the link ----- */
link.download = `dinov3_selection_t${threshold.toFixed(2)}.png`;

/*  add the next three lines  */
const bmp = exportCanvas;                  // our feathered canvas
exportCtx.filter = 'blur(0px)';
exportCtx.drawImage(bmp,0,0);              // just to be safe
exportCtx.filter = 'none';

link.href = exportCanvas.toDataURL('image/png');
link.click();
        }

        function updateButtonVisibility() {
          const hasSelections = positivePatches.size > 0 || negativePatches.size > 0;
          clearBtn.style.display = hasSelections ? "inline-block" : "none";
          exportBtn.style.display = positivePatches.size > 0 ? "inline-block" : "none";
          exportControls.style.display = positivePatches.size > 0 ? "grid" : "none";
        }

        function loadImageOntoCanvas(imageUrl) {
          currentImageUrl = imageUrl;
          originalImage = new Image();
          originalImage.onload = async () => {
            if (!patchSize) {
              updateStatus("Error: Model not ready, patch size is unknown.");
              return;
            }

            canvasPlaceholder.style.display = "none";
            imageCanvas.style.display = "block";
            positivePatches.clear();
            negativePatches.clear();
            recalculateCombinedScores();
            updateButtonVisibility();

            let newWidth = originalImage.naturalWidth * imageScale;
            let newHeight = originalImage.naturalHeight * imageScale;
            const numPixels = newWidth * newHeight;
            if (numPixels > maxPixels) {
              const scaleRatio = Math.sqrt(maxPixels / numPixels);
              newWidth *= scaleRatio;
              newHeight *= scaleRatio;
            }

            const croppedWidth = Math.floor(newWidth / patchSize) * patchSize;
            const croppedHeight = Math.floor(newHeight / patchSize) * patchSize;

            if (croppedWidth < patchSize || croppedHeight < patchSize) {
              updateStatus("Scaled image is too small to process.");
              imageCanvas.style.display = "none";
              canvasPlaceholder.style.display = "block";
              canvasPlaceholder.textContent = "Scaled image is too small.";
              return;
            }

            imageCanvas.width = croppedWidth;
            imageCanvas.height = croppedHeight;
            ctx.drawImage(originalImage, 0, 0, croppedWidth, croppedHeight);
            await processImage();
            renderCanvas();

          };
          originalImage.onerror = () => {
            updateStatus("Failed to load the selected image.");
            canvasPlaceholder.style.display = "block";
            imageCanvas.style.display = "none";
          };
          originalImage.src = imageUrl;
        }

        async function processImage() {
          updateStatus("Analyzing image...", true);
          similarityScores = null;
          isCanvasReady = false;
          const imageData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height).data;
          const data = new Uint8Array(imageData);
          worker.postMessage({
            type: "processImage",
            payload: { imageData: data, width: imageCanvas.width, height: imageCanvas.height }
          }, [data.buffer]);
        }

        function renderCanvas() {
          if (!originalImage || !ctx) return;

          ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
          ctx.drawImage(originalImage, 0, 0, imageCanvas.width, imageCanvas.height);
          updateButtonVisibility();

          const hasPermanentHighlights = cachedCombinedScores && cachedCombinedScores.length > 0;
          const hasHoverHighlight = lastHoverData && similarityScores;

          if (hasPermanentHighlights) {
            drawHighlights(ctx, cachedCombinedScores, { positive: positivePatches, negative: negativePatches });
          }

          if (hasHoverHighlight) {
            const hoverScores = similarityScores[lastHoverData.queryIndex];
            const hoverPatches = { positive: new Set([lastHoverData.queryIndex]), negative: new Set() };
            drawHighlights(ctx, hoverScores, hoverPatches, true);
          }
        }

        function getInfernoColor(t) {
          // No changes needed
        }

        function drawHighlights(targetCtx, scores, queryPatches, isTemporary = false) {
          const patchesPerRow = imageCanvas.width / patchSize;
          const validScores = scores.filter(s => s >= 0);
          if (validScores.length === 0) return;

          const minScore = Math.min(...validScores);
          const maxScore = Math.max(...validScores);
          const scoreRange = maxScore - minScore;

          if (isOverlayMode) {
            targetCtx.fillStyle = isTemporary ? "rgba(0, 0, 0, 0.4)" : "rgba(0, 0, 0, 0.6)";
            targetCtx.fillRect(0, 0, imageCanvas.width, imageCanvas.height);
          } else {
            targetCtx.fillStyle = getInfernoColor(0);
            targetCtx.fillRect(0, 0, imageCanvas.width, imageCanvas.height);
          }

          for (let i = 0; i < scores.length; i++) {
            const score = scores[i];
            if (score < 0) continue;

            const normalizedScore = scoreRange > 1e-4 ? (score - minScore) / scoreRange : 1;
            const patchY = Math.floor(i / patchesPerRow);
            const patchX = i % patchesPerRow;

            if (isOverlayMode) {
              const brightness = Math.pow(normalizedScore, 2) * (isTemporary ? 0.6 : 0.8);
              targetCtx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
            } else {
              targetCtx.fillStyle = getInfernoColor(normalizedScore);
            }
            targetCtx.fillRect(patchX * patchSize, patchY * patchSize, patchSize, patchSize);
          }

          targetCtx.lineWidth = 2;

          // Draw positive selection boxes (blue)
          targetCtx.strokeStyle = isTemporary ? "rgba(255, 255, 255, 0.9)" : "rgba(129, 188, 255, 0.9)";
          for (const queryIndex of queryPatches.positive) {
            const queryY = Math.floor(queryIndex / patchesPerRow);
            const queryX = queryIndex % patchesPerRow;
            targetCtx.strokeRect(queryX * patchSize, queryY * patchSize, patchSize, patchSize);
          }

          // Draw negative selection boxes (red)
          targetCtx.strokeStyle = "rgba(255, 100, 100, 0.9)";
          for (const queryIndex of queryPatches.negative) {
            const queryY = Math.floor(queryIndex / patchesPerRow);
            const queryX = queryIndex % patchesPerRow;
            targetCtx.strokeRect(queryX * patchSize, queryY * patchSize, patchSize, patchSize);
          }
        }
        initialize();
                /* ----------  GEMINI ROUND-TRIP  ---------- */
        
        let exportCanvas = null;   // will hold the transparent crop
        let patchCenter = null;   // centre in ORIGINAL image pixels

        /* 2-a  Hook into your existing export canvas to grab centre */
        const oldExport = handleExportSelection;
                /*  overridden export  */
        handleExportSelection = function () {
          if (positivePatches.size === 0) {
            alert("Please make at least one positive selection to export.");
            return;
          }

          const threshold = parseFloat(thresholdSlider.value);
          const patchesPerRow = imageCanvas.width / patchSize;
          const combined = cachedCombinedScores;

          /* indices above threshold */
          const kept = [];
          for (let i = 0; i < combined.length; i++)
            if (combined[i] >= threshold) kept.push(i);
          if (kept.length === 0) {
            alert("No pixels above threshold – try lowering it.");
            return;
          }

          /* bounding box in patch coords */
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          for (const idx of kept) {
            const py = Math.floor(idx / patchesPerRow);
            const px = idx % patchesPerRow;
            minX = Math.min(minX, px);
            maxX = Math.max(maxX, px);
            minY = Math.min(minY, py);
            maxY = Math.max(maxY, py);
          }

          /* centre in ORIGINAL (un-scaled) pixels */
          const scaleW = originalImage.naturalWidth  / imageCanvas.width;
          const scaleH = originalImage.naturalHeight / imageCanvas.height;
          patchCenter = {
            x: (minX + (maxX - minX + 1) / 2) * patchSize * scaleW,
            y: (minY + (maxY - minY + 1) / 2) * patchSize * scaleH
          };

          /* build transparent crop canvas (kept globally) */
          exportCanvas = document.createElement("canvas");
          exportCanvas.width  = (maxX - minX + 1) * patchSize;
          exportCanvas.height = (maxY - minY + 1) * patchSize;
          const exportCtx = exportCanvas.getContext("2d");

          const temp = document.createElement("canvas");
          temp.width  = imageCanvas.width;
          temp.height = imageCanvas.height;
          temp.getContext("2d").drawImage(originalImage, 0, 0, imageCanvas.width, imageCanvas.height);

          for (const idx of kept) {
            const py = Math.floor(idx / patchesPerRow);
            const px = idx % patchesPerRow;
            exportCtx.drawImage(temp,
              px * patchSize, py * patchSize, patchSize, patchSize,
              (px - minX) * patchSize, (py - minY) * patchSize, patchSize, patchSize);
          }

          /* download (unchanged) */
          const link = document.createElement("a");
          link.download = `dinov3_selection_t${threshold.toFixed(2)}.png`;
          link.href = exportCanvas.toDataURL("image/png");
          link.click();
        };
        /* ----------  /patched export  ---------- */

        /* 2-b  Send crop to Gemini and paste result back */
    document.getElementById('geminiSend').onclick = async () => {
        const feather = 6;   // px – same number you used in rebuildCropForGemini()
        const key = document.getElementById('geminiKey').value.trim();
        const prompt = "You will be given a rough-edged, cut-out image from a bigger image, and you are tasked with applying the requested change only inside the image patch. Ignore if outside the core subject. Work only on given subject. Here is the requested change: " + document.getElementById('geminiPrompt').value.trim();
        if (!key || !prompt) { alert("Need key + prompt"); return; }

        const ai = new GoogleGenAI({
          apiKey: key,
          baseURL: "https://generativelanguage.googleapis.com/v1alpha" // ← alpha endpoint
        });
        const blob = await new Promise(r => exportCanvas.toBlob(r, 'image/png'));
        const b64 = await blobToBase64(blob);

        updateStatus("Uploading to Gemini…", true);
        const result = await ai.models.generateContent({
          model: "gemini-2.5-flash-image-preview", // ← real image→image model
          contents: [
        { inlineData: { data: b64, mimeType: 'image/png' } },
        prompt
        ],
          config: { responseModalities: ["IMAGE"] }
        });
        updateStatus("", false);


  const newB64 = result?.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
  if (!newB64) {
    alert("Gemini did not return an image.");
    return;
  }

  const img = new Image();
  
  img.onload = () => {
  console.log("Gemini image arrived", { naturalWidth: img.naturalWidth, naturalHeight: img.naturalHeight });

  const patchSize = dinoPatchSize;
  const threshold = parseFloat(thresholdSlider.value);
  const combined = cachedCombinedScores;

  const kept = [];
  for (let i = 0; i < combined.length; i++)
    if (combined[i] >= threshold) kept.push(i);

  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const idx of kept) {
    const py = Math.floor(idx / patchesPerRow);
    const px = idx % patchesPerRow;
    minX = Math.min(minX, px);
    maxX = Math.max(maxX, px);
    minY = Math.min(minY, py);
    maxY = Math.max(maxY, py);
  }

  const outCv = document.getElementById('outCanvas');
  outCv.width = (maxX - minX + 1) * patchSize;
  outCv.height = (maxY - minY + 1) * patchSize;
  outCv.classList.remove('hidden');

const temp = document.createElement('canvas');
temp.width  = outCv.width;
temp.height = outCv.height;
const tCtx = temp.getContext('2d');
tCtx.clearRect(0, 0, temp.width, temp.height);   // ← 1. clean slate
tCtx.filter = 'blur(0px)';
tCtx.drawImage(img, 0, 0, temp.width, temp.height);
tCtx.filter = 'none';

  // ✅ Step 3: Composite the edited patch BACK onto the original image
  const scaleX = originalImage.naturalWidth / imageCanvas.width;
  const scaleY = originalImage.naturalHeight / imageCanvas.height;

  const patchX = minX * patchSize;
  const patchY = minY * patchSize;
  const patchW = (maxX - minX + 1) * patchSize;
  const patchH = (maxY - minY + 1) * patchSize;

  // ✅ Step 4: Create a **new canvas** with the edited image baked in
  const finalCanvas = document.createElement('canvas');
  finalCanvas.width = originalImage.naturalWidth;
  finalCanvas.height = originalImage.naturalHeight;
  const finalCtx = finalCanvas.getContext('2d');

  // Draw original image
  finalCtx.drawImage(originalImage, 0, 0);

/* ----------------------------------------------------------
   final paste – mask already scaled to original-pixel space
----------------------------------------------------------*/
(async () => {
  const gemini = temp;
  const mask   = exportCanvas;          // <- still the small mask

  // 1.  scale mask once
  const scaleX = originalImage.naturalWidth  / imageCanvas.width;
  const scaleY = originalImage.naturalHeight / imageCanvas.height;
  const scaledMask = document.createElement('canvas');
  scaledMask.width  = mask.width  * scaleX;
  scaledMask.height = mask.height * scaleY;
  scaledMask.getContext('2d').drawImage(mask, 0, 0, scaledMask.width, scaledMask.height);

  // 2.  RGBA canvas (same size as scaled mask)
  const rgba = document.createElement('canvas');
  rgba.width  = scaledMask.width;
  rgba.height = scaledMask.height;
  const rCtx = rgba.getContext('2d');
  rCtx.drawImage(gemini, 0, 0, rgba.width, rgba.height); // fill with RGB
  const mData = scaledMask.getContext('2d').getImageData(0,0,scaledMask.width,scaledMask.height);
  const rData = rCtx.getImageData(0,0,rgba.width,rgba.height);
  for(let i=0;i<mData.data.length;i+=4) rData.data[i+3] = mData.data[i+3];
  rCtx.putImageData(rData,0,0);

  // 3.  clip through scaled mask
  const clipped = document.createElement('canvas');
  clipped.width  = scaledMask.width;
  clipped.height = scaledMask.height;
  const cCtx = clipped.getContext('2d');
  cCtx.drawImage(scaledMask, -2, -2);   // keep your 2-px offset
  cCtx.globalCompositeOperation = 'source-in';
  cCtx.drawImage(rgba,0,0);
  cCtx.globalCompositeOperation = 'source-over';

  // 4.  kill sub-1 % alpha
  const clean = await createImageBitmap(clipped,0,0,clipped.width,clipped.height,
                       {colorSpaceConversion:'none',premultiplyAlpha:'none'});

  // 5.  stamp on original photo
  const finalCanvas = document.createElement('canvas');
  finalCanvas.width  = originalImage.naturalWidth;
  finalCanvas.height = originalImage.naturalHeight;
  const finalCtx = finalCanvas.getContext('2d');
  finalCtx.drawImage(originalImage,0,0);


// ----------------------------------------------------------
// measure the offset once (in original pixels)
// ----------------------------------------------------------

// ---- centre of the patch in ORIGINAL pixels ----
const cx = (minX + (maxX - minX + 1) / 2) * patchSize * scaleX;
const cy = (minY + (maxY - minY + 1) / 2) * patchSize * scaleY;

finalCtx.drawImage(clean,
                   0, 0, clean.width, clean.height,
                   cx - clean.width  / 2,   // centred horizontally
                   cy - clean.height / 2,   // centred vertically
                   clean.width, clean.height);


  originalImage.src = finalCanvas.toDataURL();
})();   // <-- executes immediately

// ✅ Step 6: Redraw canvases with new image
originalImage.onload = () => {
  renderCanvas(); // main canvas

  // ✅ Also draw full edited image to outCanvas
  const outCv = document.getElementById('outCanvas');
  outCv.width = imageCanvas.width;
  outCv.height = imageCanvas.height;
  outCv.classList.remove('hidden');
  const outCtx = outCv.getContext('2d');
  outCtx.clearRect(0, 0, outCv.width, outCv.height);
  outCtx.drawImage(originalImage, 0, 0, outCv.width, outCv.height);
  updateStatus("Patch applied.");
};
};
  img.src = 'data:image/png;base64,' + newB64;
}

        /* helper */
        function blobToBase64(blob){
          return new Promise((resolve,reject)=>{
              const r = new FileReader();
              r.onloadend = () => resolve(r.result.split(',')[1]);
              r.readAsDataURL(blob);
          });
        }
      });
    </script>
  </body>
</html>